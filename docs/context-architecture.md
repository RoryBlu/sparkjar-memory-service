# Memory Context Architecture

**Version:** 3.0  
**Date:** 2025-07-18
**Author:** Gemini (v1.0), Claude (v2.0-3.0)

## 1. Overview

This document outlines the foundational architecture for memory context within the SparkJAR Crew system. The context model provides the essential framework within which ALL memories exist - no memory can exist without a context.

**v3.0 UPDATE**: Introduces the concept of Context/Realm as the foundational organizing principle. Every entity MUST exist within a context defined by actor_type and actor_id. This ensures clear ownership, boundaries, and inheritance paths.

**v2.0 UPDATE**: The memory system supports hierarchical access patterns, enabling synths to inherit memories from their synth_class templates and optionally access client-level knowledge. See the [Hierarchical Memory Guide](./HIERARCHICAL_MEMORY_GUIDE.md) for implementation details.

## 2. Foundational Concept: Context (Realm)

### What is a Context?

A **context** (or **realm**) is the foundational boundary within which ALL memory entities exist. **No entity can exist without a context.** The context defines:
- **Ownership**: Who/what owns these memories
- **Access**: Who can see and use these memories  
- **Meaning**: The frame of reference for understanding the memories
- **Boundaries**: Where these memories apply and where they don't

### Critical Principle: Every Entity MUST Have a Context

```python
# WRONG - Entity without context (IMPOSSIBLE in our system)
entity = {
    "name": "Blog Writing SOP",
    "type": "procedure"
}

# CORRECT - Entity within context  
entity = {
    "name": "Blog Writing SOP",
    "type": "procedure",
    "actor_type": "synth_class",  # THE CONTEXT
    "actor_id": "24"               # SPECIFIC CONTEXT INSTANCE
}
```

Entities cannot "float" in the system - they must be anchored to a specific context that gives them meaning and boundaries.

## 3. The New Memory Context Model

To address this, we are introducing a new, three-part context model for all memories. This model is mandatory for all new memory interactions and will be retroactively applied to existing data where possible.

The new context model consists of the following three fields:

*   `client_id`: The client account that the memory is associated with.
*   `actor_type`: The type of actor that generated the memory.
*   `actor_id`: The unique identifier for the actor.

### 3.1. `client_id`

*   **Type:** `string` (UUID)
*   **Description:** This field represents the client account that the memory belongs to. It is the top-level container for all data related to a specific client.
*   **Requirement:** Mandatory for all `actor_type`s except `synth_class`.

### 3.2. `actor_type`

*   **Type:** `string` (Enum)
*   **Description:** This field specifies the type of actor that generated the memory. This is crucial for understanding the memory's origin and nature.
*   **Allowed Values:**
    *   `human`: The memory was generated by a human user interacting with the system.
    *   `synth`: The memory was generated by a specific, instantiated AI agent (a "synth").
    *   `synth_class`: The memory is associated with a class of synths, rather than a specific instance. This contains CORE IDENTITY knowledge (e.g., CFO financial expertise, Lawyer legal reasoning). **Note:** Memories of this type are not associated with a `client_id`.
    *   `client`: The memory is associated with the client account itself, rather than a specific user or agent. This is useful for storing client-level configuration or metadata.
    *   `skill_module`: **NEW** - The memory contains TOOL KNOWLEDGE that can be swapped (e.g., Microsoft 365 Suite, Odoo ERP, Salesforce CRM). These are complete, standalone skill sets. **Note:** Not associated with a `client_id`.

### 3.3. `actor_id`

*   **Type:** `string`
*   **Description:** This field contains the unique identifier for the actor. The meaning of this ID depends on the `actor_type`:
    *   If `actor_type` is `human`, this is the `user_id` of the human user.
    *   If `actor_type` is `synth`, this is the unique ID of the synth instance.
    *   If `actor_type` is `synth_class`, this is the ID of the synth class (e.g., `"24"` for blog writers).
    *   If `actor_type` is `client`, this is the `client_id`.
    *   If `actor_type` is `skill_module`, this is the unique skill identifier (e.g., `"microsoft_365_suite"`, `"odoo_erp"`).

## 4. Two Types of Knowledge: Core Identity vs Tool Skills

### 4.1 Core Identity Knowledge (synth_class)

**What it is**: The fundamental expertise that defines WHO a synth is
- CFO: Financial analysis, budgeting, forecasting, compliance
- Lawyer: Legal reasoning, contract analysis, risk assessment  
- Blog Writer: Content creation, SEO, audience engagement

**Characteristics**:
- Inseparable from the synth's identity
- Educational and professional knowledge
- Cannot be swapped out
- Defines the synth's core capabilities

### 4.2 Tool Skills (skill_module)

**What it is**: The specific tools and systems a synth knows HOW to use
- Productivity Suites: Microsoft 365, Google Workspace
- ERP Systems: SAP, Oracle, Odoo, NetSuite
- CRM Systems: Salesforce, HubSpot, Pipedrive
- Analytics Tools: Tableau, PowerBI, Looker

**Characteristics**:
- Swappable based on client needs
- Complete knowledge of the tool/suite
- Not tiered (no "basic" vs "advanced")
- Can be mixed and matched

### 4.3 How They Work Together

```
Example: CFO Synth Configuration
├── CORE IDENTITY (from synth_class "CFO")
│   ├── Financial planning & analysis
│   ├── Budgeting & forecasting
│   ├── Compliance & reporting
│   └── Strategic financial management
│
└── TOOL SKILLS (from skill_modules)
    ├── "microsoft_365_suite" OR "google_workspace"
    ├── "sap_erp" OR "odoo_erp" OR "netsuite"
    └── "tableau" OR "powerbi"
```

The synth's effectiveness comes from combining core expertise with the right tools for each client.

## 5. Context Relationships and Knowledge Graphs

### 5.1 Understanding Entity Relationships Within Contexts

Every entity exists within a context, and relationships between entities respect these context boundaries:

1. **Intra-Context Relationships**: Entities within the same context can have rich relationships
2. **Cross-Context Relationships**: Limited and controlled, typically through inheritance or subscription

### 5.2 Example: Blog Writing Knowledge Graph

The blog writing skill demonstrates how CORE IDENTITY knowledge is organized (NOT a skill_module):

```
CONTEXT: synth_class 24
├── Blog Writing SOP (procedure)
│   ├── Phase 1: Research (observation)
│   ├── Phase 2: Writing (observation)
│   ├── Phase 3: Optimization (observation)
│   └── Phase 4: QA (observation)
├── Quality Checklist (checklist)
│   └── validates → Blog Writing SOP
├── Style Guide (style_guide)
│   └── supports → Blog Writing SOP
├── Blog Template (template)
│   └── implements → Blog Writing SOP
└── Performance Metrics (metrics_framework)
    └── measures → Blog Writing SOP
```

**Key Insights:**
- All these entities EXIST WITHIN synth_class 24's context
- They have no meaning outside this context
- Relationships connect entities within the same context
- The context itself (synth_class 24) is the root entity

### 4.3 Cross-Context Usage

When a synth (different context) creates a blog:

```
CONTEXT: synth 12345
└── "10 AI Tips Blog Post" (content_output)
    └── followed_procedure → Blog Writing SOP (in synth_class 24 context)
```

The blog post EXISTS in the synth's context but REFERENCES knowledge in the class context through the hierarchical memory system.

### 4.4 Why Context Matters for Relationships

1. **Clear Ownership**: Blog SOP belongs to synth_class 24, not to any individual synth
2. **Inheritance Path**: Synths of class 24 can access these procedures
3. **Boundary Enforcement**: Synths of class 25 cannot directly access class 24's procedures
4. **Relationship Scope**: Relationships are meaningful within their context

## 5. Design Principles for Context-Aware Systems

### 5.1 Context First Design
Always determine the context before creating any entity:
- What realm does this belong to?
- Who owns this knowledge?
- What are the natural boundaries?

### 5.2 Entity Uniqueness Within Context
Each entity name must be unique within its context:
- `synth_class 24` can have only ONE "Blog Writing SOP"
- Different contexts can have entities with the same name
- Context + entity_name = globally unique

### 5.3 Relationship Patterns
Common patterns for context-aware relationships:
- **Inheritance**: synth → uses → synth_class procedures
- **Enhancement**: synth → improves → synth_class procedures
- **Validation**: checklist → validates → procedure (same context)
- **Implementation**: output → followed → procedure (cross-context)

## 6. Implementation and Impact

This new memory context model has the following implications:

*   **Memory Service:** The memory service's API now requires the new three-part context for all memory creation and modification operations.
*   **Memory Tools:** The `SJMemoryTool` and any other tools that interact with the memory service must be updated to provide this new context.
*   **Crews:** All crews that interact with the memory system must be updated to correctly generate and pass the new context to the memory tools.
*   **API Endpoints:** API endpoints that trigger memory operations, such as the `message_api`, must be updated to correctly handle the new context.

## 5. Example Scenarios

| Scenario                               | `client_id` | `actor_type`  | `actor_id`              |
| -------------------------------------- | ----------- | ------------- | ----------------------- |
| Human user submits a contact form      | `client-123`| `human`       | `user-456`              |
| An AI agent analyzes an email          | `client-123`| `synth`       | `synth-instance-789`    |
| General knowledge for all support bots | `null`      | `synth_class` | `"support_bot_crew"`    |
| Client-level configuration is updated  | `client-123`| `client`      | `client-123`            |
